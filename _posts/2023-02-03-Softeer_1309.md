---
layout: single
title: "성적 평가"
categories: Softeer
tag: [java, Softeer]
---

## 문제
---
현주는 N명의 인원이 참여하는 프로그래밍 스터디 그룹을 이끌고 있다.

현주는 스터디를 위해 대회를 세 개 개최하였고, 모든 구성원이 각 대회에 참여하였다. 참가자는 각 대회에서 0 이상 1,000 이하의 정수인 점수를 얻는다. 한 대회에서 둘 이상의 참가자가 동점이 나오는 경우도 있을 수 있다.

현주는 각 대회별 등수 및 최종 등수를 매기고 싶다. 등수는 가장 점수가 높은 사람부터 1등, 2등, ···, N등의 순서대로 붙는다. 만일 동점이 있을 경우 가능한 높은 (등수의 수가 작은) 등수를 부여한다. 즉, 점수가 내림차순으로 10,7,6,6,4의 순서일 경우, 6점을 받은 두 사람은 공동 3등이 되고, 그 다음 순서인 4점을 받은 사람은 5등이 된다. 이 규칙을 다르게 표현하면 다음과 같다: 각 사람마다 “나보다 점수가 큰 사람”의 수를 세어 1을 더한 것이 자신의 등수가 된다. 대회별 등수는 각 대회에서 얻은 점수를 기준으로 하며 최종 등수는 세 대회의 점수의 합을 기준으로 한다.

각 참가자의 대회별 등수 및 최종 등수를 출력하는 프로그램을 작성하시오.


## 제한사항

---

- 3 ≤ N ≤ 100,000

- 첫째 줄에 참가자의 수를 나타내는 정수 N이 주어진다.

- 이어 세 개의 줄에 각 대회의 결과를 나타내는 N개의 정수가 주어진다. 이중 i번째 정수는 그 대회에서 i번째 사람이 얻은 점수를 의미한다.

- 첫 세 개의 줄에는 각 참가자의 대회별 등수를 출력한다. 즉 이중 c번째 줄의 i번쨰 정수는 c번째 대회에서의 i번째 사람의 등수를 의미한다. 이어 새로운 줄에 같은 형식으로 각 참가자의 최종 등수를 출력한다.

### 입력예제1

```
3
40 80 70
50 10 20
100 70 30
```

### 출력예제1

```
3 1 2
1 3 2
1 2 3
1 2 3
```

### 입력예제2

```
3
1000 1000 700
300 100 400
200 400 400
```

### 출력예제2

```
1 1 3
2 3 1
3 1 1
1 1 1
```


## 풀이

---

```java
import java.util.*;
import java.io.*;


public class Main
{
    /*  기존 풀이 O(n^2)이기에 시간초과가 발생한다.
        따라서 O(n)으로 순위 정렬을 하는 알고리즘을 찾아 적용해본다.
        public static void main(String args[]) throws Exception
        {
            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
            int N = Integer.parseInt(br.readLine());
            int[][] scores = new int[3][N];
            int[] totalScores = new int[N];
            for(int i = 0; i < 3; i++){
                StringTokenizer st = new StringTokenizer(br.readLine());
                for(int j = 0; j < N; j++){
                    scores[i][j] = Integer.parseInt(st.nextToken());
                    totalScores[j] += scores[i][j];
                }
            }
            int[][] ranks = new int[4][N];
            for(int i = 0; i < 3; i++){
                for(int j = 0; j < N; j++){
                    int cur = scores[i][j];
                    for(int k = 0; k < N; k++){
                        if(cur < scores[i][k])
                            ranks[i][j]++;
                    }
                    ranks[i][j]++;
                }
            }
            for(int i = 0; i < N; i++){
                int cur = totalScores[i];
                for(int k = 0; k < N; k++){
                    if(cur < totalScores[k])
                        ranks[3][i]++;
                }
                ranks[3][i]++;
            }
            // System.out.println(Arrays.deepToString(ranks));
            StringBuilder sb = new StringBuilder();
            for(int i = 0; i < 4; i++){
                for(int j = 0; j < 3; j++){
                    sb.append(ranks[i][j]).append(" ");
                }
                sb.append("\n");
            }
            System.out.println(sb);
        }
    */
    /*  기존 풀이와 다르게 순위 매기는 알고리즘에 점수 최대값을 이용해 O(N^2)을 O(3000N)으로 바꿨다
     *  그래도 시간초과가 아슬아슬하게 발생했고, 3000에서 더 줄일 수 있도록 최대값을 지정하고자 했다.
     */ 
        // public static void main(String[] args) throws Exception{
        //     BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        //     int N = Integer.parseInt(br.readLine());
        //     int[][] scores = new int[4][N+1]; // N에서 N+1로 최대값을 넣기 위해 공간 1 증가가
        //     for(int i = 0; i < 3; i++){
        //         StringTokenizer st = new StringTokenizer(br.readLine());
        //         for(int j = 0; j < N; j++){
        //             scores[i][j] = Integer.parseInt(st.nextToken());
        //             if(scores[i][j] > scores[i][N])
        //                 scores[i][N] = scores[i][j];
        //             scores[3][j] += scores[i][j];
        //         }
        //     }
        //     for(int i = 0; i < N; i++)
        //         if(scores[3][N] < scores[3][i])
        //             scores[3][N] = scores[3][i];
        //     int[][] results = new int[4][N];
        //     for(int i = 0; i < 4; i++){
        //         // 점수의 최댓값이 1000이고, 세 개 대회 최종 등수 역시 구해야 하므로 상한을 3000으로 생각
        //         int[] ranks = new int[scores[i][N] + 1];
        //         for(int score = 0; score <= scores[i][N]; score++){
        //             int rank = 1;
        //             for(int j = 0; j < N; j++){
        //                 if(scores[i][j] > score)
        //                     rank++;
        //             }
        //             ranks[score] = rank;
        //         }
        //         for(int j = 0; j < N; j++)
        //             results[i][j] = ranks[scores[i][j]];
        //     }
        //     StringBuilder sb = new StringBuilder();
        //     for(int[] arr : results){
        //         for(int i : arr)
        //             sb.append(i).append(" ");
        //         sb.append("\n");
        //     }
        //     System.out.println(sb);
        //     // System.out.println(Arrays.deepToString(results));
        // }

    // public static void main(String[] args) throws Exception{
    //     BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    //     StringBuilder sb = new StringBuilder();
    //     int N = Integer.parseInt(br.readLine());
    //     List<Integer>[] score = new List[N];
    //     for(int i = 0; i < 3; i++){
    //         score[i] = new ArrayList();
    //         StringTokenizer st = new StringTokenizer(br.readLine());
    //         for(int j = 0; j < N; j++){
    //             int cur = Integer.parseInt(st.nextToken());
    //             score[i].add(cur);
    //         }
    //     }
    //     int[] sum = new int[N];
    //     for(List<Integer> arr : score){
    //         // System.out.print(arr.toString() + "\t");
    //         HashMap<Integer, Integer> hash = new HashMap();
    //         int idx = 0;
    //         Iterator<Integer> iter = arr.iterator();
    //         while(iter.hasNext()){
    //             sum[idx++] += iter.next();
    //         }
    //         idx = 0;
    //         List<Integer> sorted_score = merge_sort(arr);
    //         System.out.print(sorted_score.toString() + "\t");
    //         for(int i : sorted_score){
    //             idx++;
    //             if(!hash.containsKey(i))
    //                 hash.put(i, idx);
    //         }
    //         for(int i = 0; i < arr.size(); i++){
    //             sb.append(hash.get(arr.get(i))).append(" ");
    //         }
    //         sb.append("\n");
    //         System.out.println(hash.toString());
    //     }
    //     List<Integer> total = new ArrayList();
    //     for(int i : sum)
    //         total.add(i);
    //     HashMap<Integer, Integer> hash = new HashMap();
    //     int idx = 0;
    //     List<Integer> sorted_score = merge_sort(total);
    //     for(int i : sorted_score){
    //         idx++;
    //         if(!hash.containsKey(i))
    //             hash.put(i, idx);
    //     }
    //     for(int i = 0; i < total.size(); i++){
    //         sb.append(hash.get(total.get(i))).append(" ");
    //     }
    //     System.out.println(sb);
    // }
    // public static List<Integer> merge_sort(List<Integer> arr){
    //     // System.out.println(arr.toString());
    //     if(arr.size() < 2)
    //         return arr;
    //     int mid = arr.size() / 2;
    //     List<Integer> low_arr = merge_sort(arr.subList(0, mid));
    //     List<Integer> high_arr = merge_sort(arr.subList(mid, arr.size()));
    //     List<Integer> merged_arr = new ArrayList<Integer>();
    //     int l = 0, h = 0;
    //     while(l < low_arr.size() && h < high_arr.size()){
    //         System.out.println("mergeloop\t" + merged_arr.toString());
    //         if(low_arr.get(l) < high_arr.get(h)){
    //             merged_arr.add(low_arr.get(l++));
    //         }
    //         else
    //             merged_arr.add(high_arr.get(h++));
    //     }
    //     if(l < low_arr.size()){
    //         merged_arr.addAll(l, low_arr);
    //         System.out.println("low append");
    //     }
    //     if(h < high_arr.size()){
    //         merged_arr.addAll(h, high_arr);
    //         System.out.println("high append");
    //     }
    //     return merged_arr;
    // }
    public static void main(String[] args) throws Exception{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(br.readLine());
        int[][] scores = new int[4][N];
        StringBuilder sb = new StringBuilder();
        for(int i = 0; i < 3; i++){
            StringTokenizer st = new StringTokenizer(br.readLine());
            for(int j = 0; j < N; j++){
                scores[i][j] = Integer.parseInt(st.nextToken());
                scores[3][j] += scores[i][j];
            }
        }
        int[][] clones = new int[4][];
        for(int i = 0; i < 4; i++){
            clones[i] = scores[i].clone();
            Arrays.sort(clones[i]);
        }
        for(int j = 0; j < 4; j++){
            int[] cur = clones[j];
            HashMap<Integer, Integer> hash = new HashMap();
            int idx = 0;
            for(int i = cur.length-1; i >= 0; i--){
                idx++;
                if(!hash.containsKey(cur[i]))
                    hash.put(cur[i], idx);
            }
            for(int i = 0; i < N; i++){
                sb.append(hash.get(scores[j][i])).append(" ");
            }
            sb.append("\n");
            // System.out.println(hash.toString());
        }
        System.out.println(sb);
    }
}
```