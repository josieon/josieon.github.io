---
layout: single
title: "2251번: 물통"
categories: BOJ
tag: [java, BOJ]
---

## 문제
---
각각 부피가 A, B, C(1≤A, B, C≤200) 리터인 세 개의 물통이 있다. 처음에는 앞의 두 물통은 비어 있고, 세 번째 물통은 가득(C 리터) 차 있다. 이제 어떤 물통에 들어있는 물을 다른 물통으로 쏟아 부을 수 있는데, 이때에는 한 물통이 비거나, 다른 한 물통이 가득 찰 때까지 물을 부을 수 있다. 이 과정에서 손실되는 물은 없다고 가정한다.

이와 같은 과정을 거치다보면 세 번째 물통(용량이 C인)에 담겨있는 물의 양이 변할 수도 있다. 첫 번째 물통(용량이 A인)이 비어 있을 때, 세 번째 물통(용량이 C인)에 담겨있을 수 있는 물의 양을 모두 구해내는 프로그램을 작성하시오.

## 입력
---
첫째 줄에 세 정수 A, B, C가 주어진다.

## 출력
---
첫째 줄에 공백으로 구분하여 답을 출력한다. 각 용량은 오름차순으로 정렬한다.

### 예제 입력 1 

```
8 9 10
```

### 예제 출력 1 

```
1 2 8 9 10
```

## 풀이
---
&nbsp;BFS를 이용해 풀어야겠다는 생각이 처음에 들었다. 노드 구조체를 사용해야 하나 싶었는데 사용하지 않고 풀 수 있겠다 싶어 고민을 했으나, 마땅히 해법이 떠오르지 않았다. 알고리즘은 아래와 같다.
- 현재 세 개의 물통의 물양을 가지는 노드 구조체를 만든다. 그리고 move라는 함수를 만들어 변화된 물양을 가지는 노드를 리턴하도록 한다.
- check라는 탐색 배열을 할당하여 A, B 두개의 물통의 양을 좌표값으로하여 탐색하였으면 true로 boolean값을 바꾼다.
- A의 물양이 0이라면 세트에 C의 물양을 추가하고, 현재 물양에서 모든 경우(A -> B, A -> C, B -> C, C -> A, C -> B)를 탐색하여 check가 false라면 true로 바꾸고 큐에 추가시킨다.

구글링을 하다가 DFS를 이용해 푼 방법도 있었다. 이는 재귀호출을 사용하여 코드가 훨씬 간단하고 구현 시간도 더 짧게 걸린다. 하지만, 메모리 사용량이 많기 때문에 메모리가 더 제한적인 상황이라면 BFS를 이용함이 옳다. BFS와 DFS를 비교하였을때 수행시간은 동일하였다.
- check 탐색 배열과 A, B, C의 현재 물양을 파라미터로 가지는 dfs함수를 이용해 해결한다.
- 위의 BFS와 공통된 부분이지만, 물양을 옮기는 로직은 다음과 같다.
- from에서 to로 물을 옮긴다고 할 때, to의 물통의 크기가 from의 물양 + to의 물양보다 작다면 to의 물양은 물통의 크기만큼이고, from의 물양은 from의 물양 + to의 물양 - to의 물통의 크기이다.
- 그 외의 경우는 from의 물양은 0이 될 것이고, to의 물양은 from의 물양 + to의 물양이 될 것이다.

```java
//BFS 풀이
import java.io.*;
import java.util.*;
public class _2251 {
    static class bucket{
        int[] tmp;  //현재 물양
        public bucket(int[] tmp){
            this.tmp = new int[3];
            for(int i = 0; i < 3; i++)
                this.tmp[i] = tmp[i];
        }
        //물양을 옮기고 난 다음 상태의 bucket을 리턴
        bucket move(int from, int to){
            int[] ttmp = {tmp[0], tmp[1], tmp[2]};
            if(tmp[from] + tmp[to] > limit[to]){
                ttmp[from] = tmp[from] + tmp[to] - limit[to];
                ttmp[to] = limit[to];
            }
            else{
                ttmp[from] = 0;
                ttmp[to] = tmp[from] + tmp[to];
            }
            return new bucket(ttmp);
        }
    }
    static Set<Integer> set = new TreeSet<>();  //정답 세트
    static int[] limit; //물통 크기
    static boolean[][] check;   //탐색 배열
    public static void main(String[] args) throws Exception{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        limit = new int[3];
        limit[0] = Integer.parseInt(st.nextToken());
        limit[1] = Integer.parseInt(st.nextToken());
        limit[2] = Integer.parseInt(st.nextToken());
        bfs();
        StringBuilder sb = new StringBuilder();
        for(int num : set){
            sb.append(num).append(" ");
        }
        System.out.println(sb);
    }
    //BFS 알고리즘
    public static void bfs(){
        Queue<bucket> q = new LinkedList<>();
        q.add(new bucket(new int[] {0, 0, limit[2]}));  //큐에 초기상태 삽입
        check = new boolean[201][201];
        check[0][0] = true;
        while(!q.isEmpty()){
            bucket p = q.poll();
            // A 물통의 물양이 0이면 세트에 정답 추가
            if(p.tmp[0] == 0)
                set.add(p.tmp[2]);
            //반복문을 통해 모든 경우에 대해 탐색
            for(int i = 0; i < 3; i++)
                for(int j = 0; j < 3; j++){
                    if(i != j){
                        bucket next = p.move(i, j);
                        //탐색하지 않은 경우라면 큐에 추가
                        if(!check[next.tmp[0]][next.tmp[1]]){
                            check[next.tmp[0]][next.tmp[1]] = true;
                            q.add(next);
                        }
                    }
                }
        }
    }
}
```

```java
//DFS 풀이
import java.util.*;
import java.io.*;
public class _2251{
    static Set<Integer> set = new TreeSet<>();  //정답 세트
    static final int[] limit = new int[3];  //물통의 크기
    static boolean[][] check = new boolean[201][201];   //탐색 배열
    public static void main(String[] args) throws Exception{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine(), " ");
        limit[0] = Integer.parseInt(st.nextToken());
        limit[1] = Integer.parseInt(st.nextToken());
        limit[2] = Integer.parseInt(st.nextToken());
        dfs(0, 0, limit[2]);
        StringBuilder sb = new StringBuilder();
        for(int num : set)
            sb.append(num).append(" ");
        System.out.println(sb);
    }
    //현재 모든 물통의 물양을 파라미터로 가짐
    public static void dfs(int a, int b, int c){
        //탐색하였던 상태라면 return
        if(check[a][b]) return;
        // A 물통의 물양이 0이라면 세트에 추가
        if(a == 0)
            set.add(c);
        check[a][b] = true;
        // A -> B
        if(a+b > limit[1])
            dfs(a+b-limit[1], limit[1], c);
        else
            dfs(0, a+b, c);
        // B -> A
        if(a+b > limit[0])
            dfs(limit[0], a+b-limit[0], c);
        else
            dfs(a+b, 0, c);
        // A -> C
        dfs(0, b, a+c);
        // C -> A
        if(a+c > limit[0])
            dfs(limit[0], b, a+c-limit[0]);
        else
            dfs(a+c, b, 0);
        // B -> C
        dfs(a, 0, b+c);
        // C -> B
        if(b+c > limit[1])
            dfs(a, limit[1], b+c-limit[1]);
        else
            dfs(a, b+c, 0);
        // A -> C 혹은 B -> C의 경우 무조건 C 물통의 크기보다 작으므로 조건 불필요
    }
}
```