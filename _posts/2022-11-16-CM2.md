---
layout: single
title: CM1
categories:
tag: [java]
---

## 문제
---

<img src = "https://user-images.githubusercontent.com/76546008/202069897-933cdd80-0d74-458e-b3d0-e897d7a6aac9.png"/>

<img src="https://user-images.githubusercontent.com/76546008/202069904-835b68e7-5573-4226-b5bc-b303687f3267.png"/>

<img src="https://user-images.githubusercontent.com/76546008/202069911-03068511-49c4-40ad-b7bd-55819e456684.png"/>

<img src="https://user-images.githubusercontent.com/76546008/202069916-6376a3b4-faff-4773-bb73-d7d030851a70.png"/>

<img src="https://user-images.githubusercontent.com/76546008/202069919-7fb1e18e-ae5a-4b5e-854d-d2f1578923b7.png"/>

<img src="https://user-images.githubusercontent.com/76546008/202069928-4d1f7984-f3be-40a7-9c50-45bef4e2dbc7.png"/>

<img src="https://user-images.githubusercontent.com/76546008/202069936-4bbeb0ea-a61b-4e3f-9594-13cab3132ee2.png"/>


## 풀이
---

&nbsp;적합한 알고리즘이나 자료구조를 떠올리지 못했다. 따라서, 구현으로 생각하고 노드 클래스를 만들어 풀었다. 정답을 구하는 메소드가 recursion으로 구현되었기에 시간 복잡도는 잘 모르겠으나, 공간 복잡도는 최악의 경우 초과가 날 수 있을 것 같다는 생각이 든다. 최악의 경우를 생각하면 함수의 recursion이 n-1번만큼 발생하고, 메모리의 스택 영역에 n-1만큼의 노드들이 할당되고 node 클래스의 사이즈는 16바이트를 넘기 때문이다.

&nbsp;정답을 구하기 위한 과정을 개략적으로 구분해보자면 다음과 같다.

1. 입력값들로 자료구조 및 변수 초기화
1. 하위 노드부터 상한에 맞추어 갱신
1. 상위 노드의 사용량이 상한에 초과되었을 경우 하위 노드의 전자기기 제거

&nbsp;2번과 3번의 과정을 묶을 수 있는 방법이 있을 것 같지만, 구상이 쉽게 되지 않아 구분을 하여 구현하였다.

```java
class node{
    int devices;    // 현재 노드의 전자기기 수
    int limit;  // 현재 노드의 상한
    int power;  // 현재 노드의 사용량
    node parent;    // 현재 노드의 부모
    ArrayList<node> child;  // 현재 노드의 자식 노드

    node(int limit){
        this.child = new ArrayList<>();
        this.limit = limit;
    }

    // 노드의 파워를 계산하는 메소드
    public int compute(){
        int pow = 0;
        // 자식 노드이 파워를
        // recursion을 통해 계산
        for(node c : this.child){
            pow += c.compute();
        }
        // 현재 노드의 전자기기
        pow += this.devices;
        this.power = pow;
        return pow;
    }

    // 전자기기 1개 제거하는 메소드
    // 루트 노드까지 반복문을 통해
    // 부모 노드의 파워 갱신
    public void remove(){
        this.power--;
        this.devices--;
        node target = this.parent;
        while(target != null){
            target.power--;
            target = target.parent;
        }
    }

    // 정답을 구하는 메소드
    // 반복문을 통해 자식노드도
    // 본 메소드 호출
    public int clear(){
        int answer = 0;
        // 자식노드도 recursive하게 수행
        for(node c : this.child){
            answer += c.clear();
        }
        // 노드의 파워가 상한보다 크다면
        // 현재 노드의 전자기기를 모두 제거
        while(this.power > this.limit && this.devices > 0){
            this.remove();
            answer++;
        }
        // 노드의 파워가 여전히 상한보다 크다면
        // 자식 노드의 전자기기를 제거
        while(this.power > this.limit){
            this.kill();
            answer++;
        }
        return answer;
    }

    // 자식의 전자기기를 제거하는 메소드
    public boolean kill(){
        if(this.devices > 0){
            this.remove();
            return true;
        }
        for(node c : child){
            if(c.kill())
                return true;
        }
        return false;
    }

    // 부모를 지정하는 메소드
    public void setParent(node p){
        this.parent = p;
    }

    // 전자기기 수 갱신하는 메소드
    public void setDevice(int n){
        this.devices = n;
    }
}

public class _2 {
    public static void main(String[] args) throws Exception{        

        // CASE 1
        int k = 300;
        int[] limits = {2000, 1000, 3000, 200, 600, 500};
        int[][] sockets = {% raw %}{{2,3,-1,-1,-1}, {4, 0, -1, -1, 6}, {5, -1, -1, -1, -1}, {-1, 0, 0, 0, 0}, {-1, -1, -1, -1, -1}, {-1, -1, 0, 0, 0}}{% endraw %};

        // CASE 2
        // int k = 120;
        // int[] limits = {1500, 300, 250, 359, 600};
        // int[][] sockets = {% raw %}{{2,3,4,0,-1}, {0,0,0,0,0}, {-1,-1,-1,0,0}, {0,0,5,0,0},{-1,0,0,-1,-1}}{% endraw %};
        System.out.println(solution(k, limits, sockets));
    }
    public static int solution(int k, int[] limits, int[][] sockets){
        HashMap<Integer, node> hash = new HashMap<>();

        // 노드의 내용을 설정하는 반복문
        for(int i = 0; i < limits.length; i++){
            // 노드의 상한을 전력값이 아닌 개수로 함
            node cur = hash.getOrDefault(i+1, new node(limits[i] / k));
            int count = 0;  // 전자기기 수 카운트
            // 현재 노드의 내용을 보는 반복문
            for(int j = 0; j < 5; j++){
                if(sockets[i][j] == -1)
                    count++;
                // 자식과 부모 설정
                else if(sockets[i][j] != 0){
                    node child = hash.getOrDefault(sockets[i][j], new node(limits[sockets[i][j]-1] / k));
                    cur.child.add(child);
                    child.setParent(cur);
                    hash.put(sockets[i][j], child);
                }
            }
            cur.setDevice(count);   // 전자기기 수 할당
            hash.put(i+1, cur);
        }

        // 1번 콘센트에서 파워 계산 메소드 호출
        // recursive하게 작동하기에
        // 자식 노드들도 계산 완료
        hash.get(1).compute();

        // 1번 콘센트에서 정답 계산 메소드 호출
        return hash.get(1).clear();
    }
}
```
