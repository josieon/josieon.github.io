---
layout: single
title: CM1
categories:
tag: [java]
---

## 문제
---

<img src = "https://user-images.githubusercontent.com/76546008/202069022-ff573b86-d141-44c7-887c-039c14ea738b.png"/>

<img src="https://user-images.githubusercontent.com/76546008/202069175-0c22d964-3532-4d18-a973-8df7f484677f.png"/>

<img src="https://user-images.githubusercontent.com/76546008/202069241-25c3616c-ab97-4b3e-922f-38419cd476dd.png"/>

<img src="https://user-images.githubusercontent.com/76546008/202069300-4c3d63e2-1b9b-4083-8a5b-cecb47de22fe.png"/>

<img src="https://user-images.githubusercontent.com/76546008/202069338-262bfd4d-c0d9-4287-8b22-c4a83cfa54a8.png"/>

<img src="https://user-images.githubusercontent.com/76546008/202069389-f1e5c8e0-e8b8-4837-a7fe-2606d2f7ed7b.png"/>

<img src="https://user-images.githubusercontent.com/76546008/202069424-9b2dda86-7a42-4510-af2f-e418389a3f1d.png"/>

<img src="https://user-images.githubusercontent.com/76546008/202069469-50363012-6171-4dbe-a29c-368e248d48cb.png"/>


## 풀이
---
&nbsp;우선 n의 사이즈가 9까지인점, 그리고 중복된 구슬도 존재하고 이를 조합한다는 점에서 바로 순열과 조합이 떠올랐다.

&nbsp;이 문제는 정답이 무조건 존재하기에, 사이즈가 1인 순열들 중에서 가장 최적의 값으로 초기화를 해준다.

&nbsp;combination과 permutation을 사용하여 순열 배열을 꾸리고, 기존의 정답 배열과 비교를 통해 최적의 값을 찾아나간다.

```java
public class _1 {
    public static int[] answer; // {Sub, Sum, Array}
    // 비교를 위해 정답 배열의 첫번째 값은 저울의 왼쪽과 오른쪽 원소의 개수 차이
    // 정답 배열의 두번째 값은 배열의 합을 할당하고, 배열은 세번째 값부터이다.
    public static void main(String[] args) throws Exception{
        int[] arr = {7, 3, 1};

        // 길이가 1인 정답 배열을 초기화해주기 위해 정렬
        Arrays.sort(arr);

        // 가장 큰 값으로 정답 배열 초기화
        answer = new int[] {0, arr[arr.length-1], arr[arr.length-1]};

        // 순열 사용
        for(int i = 2; i <= arr.length; i++)
            combination(new int[i], arr, i, 0, 0);
        System.out.println(Arrays.toString(answer));
    }

    // 순열 메소드
    // 현재의 정답과 비교하여 더 좋은 결과의 정답을 찾음
    public static void permutation(int[] arr, int start){
        if(start == arr.length - 1){
            int L = 0, R = start, sumL = 0, sumR = 0;
            int M = -1;

            // 중심을 찾는 반복문
            while(L <= R){
                if(sumL == sumR && L == R){
                    M = L;
                    break;
                }
                if(sumL < sumR)
                    sumL += arr[L++];
                else
                    sumR += arr[R--];
            }

            // 균형이 맞지 않는 경우
            if(sumL != sumR)
                return;

            // 비교를 위해 현재 배열의 양쪽 원소 개수의 차이
            // 배열의 합을 계산하여 할당
            int[] cur = new int[arr.length+2];
            cur[0] = Math.abs(arr.length - 1 - R - L);
            for(int i = 0 ; i < arr.length; i++)
                cur[1] += arr[i];
            for(int i = 0; i < arr.length; i++)
                cur[i+2] = arr[i];

            // 1번 조건: 양쪽 원소 개수의 차이가 적을수록

            // 정답의 원소 개수 차이가 적은 경우_1번
            if(cur[0] > answer[0])
                return;
            // 현재의 원소 개수 차이가 적은 경우_1번
            else if(cur[0] < answer[0]){
                answer = cur.clone();
                return;
            }

            // 정답과 현재의 원소 개수 차이 동일_1번

            // 2번 조건: 원소의 개수가 더 많을수록

            // 정답의 원소 개수가 더 많은 경우_2번
            if(cur.length < answer.length)
                return;
            // 현재의 원소 개수가 더 많은 경우_2번
            else if(cur.length > answer.length){
                answer = cur.clone();
                return;
            }

            // 정답과 현재의 원소 개수가 동일_2번

            // 3번 조건: 배열의 합이 더 클수록

            // 정답 배열의 합이 더 큰 경우_3번
            if(cur[1] < answer[1])
                return;
            // 현재 배열의 합이 더 큰 경우_3번
            else if(cur[1] > answer[1]){
                answer = cur.clone();
                return;
            }

            // 정답과 현재 배열의 합이 동일_3번

            // 4번 조건: 사전순으로 더 빠를경우
            
            for(int i = 2; i < cur.length; i++){
                if(cur[i] != answer[i]){
                    if(cur[i] < answer[i]){
                        answer = cur.clone();
                        return;
                    }
                    return;
                }
            }
        }
        for(int i = start; i < arr.length; i++){
            swap(arr, start, i);
            permutation(arr, start+1);
            swap(arr, start, i);
        }
    }
    public static void swap(int[] arr, int n1, int n2){
        int tmp = arr[n1];
        arr[n1] = arr[n2];
        arr[n2] = tmp;
    }
    public static void combination(int[] comb, int[] arr, int r, int idx, int target){
        if(r == 0)
            permutation(comb, 0);
        else if(target == arr.length)
            return;
        else{
            comb[idx] = arr[target];
            combination(comb, arr, r-1, idx+1, target+1);
            combination(comb, arr, r, idx, target+1);
        }
    }
}

```

&nbsp;문제가 상대적으로 쉬운편인데, 응시 당시 컨디션이 안 좋아서 조건문에서 계속 실수를 했던것 같다.