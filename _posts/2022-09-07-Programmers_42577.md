---
layout: single
title: "전화번호 목록"
categories: Programmers
tag: [java, Programmers]
---

## 문제
---
전화번호부에 적힌 전화번호 중, 한 번호가 다른 번호의 접두어인 경우가 있는지 확인하려 합니다.
전화번호가 다음과 같을 경우, 구조대 전화번호는 영석이의 전화번호의 접두사입니다.

- 구조대 : 119
- 박준영 : 97 674 223
- 지영석 : 11 9552 4421  

전화번호부에 적힌 전화번호를 담은 배열 phone_book 이 solution 함수의 매개변수로 주어질 때, 어떤 번호가 다른 번호의 접두어인 경우가 있으면 false를 그렇지 않으면 true를 return 하도록 solution 함수를 작성해주세요.

## 제한사항
---
- phone_book의 길이는 1 이상 1,000,000 이하입니다.
    - 각 전화번호의 길이는 1 이상 20 이하입니다.
    - 같은 전화번호가 중복해서 들어있지 않습니다.

## 입출력 예
---  

| phone_book | return          |
|: ------------- |:-------------:|
| ["119", "97674223", "1195524421"]   | false |
| ["123","456","789"] | true   |
| ["12","123","1235","567","88"] | false  |

## 입출력 예에 대한 설명
---
입출력 예 #1  
앞에서 설명한 예와 같습니다.

입출력 예 #2  
한 번호가 다른 번호의 접두사인 경우가 없으므로, 답은 true입니다.

입출력 예 #3  
첫 번째 전화번호, “12”가 두 번째 전화번호 “123”의 접두사입니다. 따라서 답은 false입니다.

## 풀이
---
&nbsp; 이건 Comparator를 이용한 문제라는 것을 직감적으로 느꼈다. 문자열의 길이를 기준으로 오름차순으로 정렬을 하고, 기준 문자열 뒤에 위치하는 문자열과 비교하여 접두사에 기준 문자열이 위치하면 false를 리턴하는 식으로 말이다.  
&nbsp; 문제는 정답처리가 되었지만 효율성에서 50%밖에 정답처리가 되지 않았다. 시간 초과. 원인 분석을 했다.  
&nbsp; Comparator 오버라이드를 효율적으로 하지 못했나? 조건문을 하나 생략할 수 있었다.  
&nbsp; 그러나 여전히 시간 초과. 반복문 내에서 기준 문자열과 비교하는 문자열을 자르는 함수의 오버헤드가 큰가? 기존에는 문자열을 substring으로 잘라서 비교하던 것을 indexOf를 함수를 사용해 코드를 줄이고, 메모리 사용량도 줄였다.  
&nbsp; 여전히 시간 초과. 질문 게시판을 뒤졌다. 테스트 케이스 3, 4번에 시간초과가 발생하는 나와 동일한 사람들이 많았다. 그렇게 찾다가 sort를 할때 comparator를 사용하지 않는 것을 발견했다.
&nbsp; 그렇다. 굳이 길이순으로 정렬할 필요가 없이 아스키 코드 순으로 정렬된 문자열 배열에 기준 문자열과 그 다음에 위치하는 문자열만 비교하면 되었다. 왜냐하면, 아스키 코드 순으로 정렬하면 자연스레 접두사를 기준으로 정렬하게 되고, 이러면 이중 반복문을 돌면서 문자열 비교를 할 필요가 없기 때문이다.  
&nbsp; 따라서, 이 문제는 comparator문제가 아니었다.

---

## 기존 코드

```java
public class _문제1 {
    public static void main(String[] args) throws Exception{
        String[] phone_book = {"119", "97674223", "1195524421", "118"};
        Arrays.sort(phone_book, new customComparator());
        for(int i = 0; i < phone_book.length - 1; i++){
            String s = phone_book[i];
            for(int j = i + 1; j < phone_book.length; j++)
                if(phone_book[j].indexOf(s) == 0)
                    return false;
        }
        return true;
    }
}
class customComparator implements Comparator<String>{
    @Override
    public int compare(String o1, String o2){
        int len = o1.length() - o2.length();
        return len;
    }
}
```

---

## 변경 코드
```java
class Solution {
    public boolean solution(String[] phone_book) {
        Arrays.sort(phone_book);
        for(int i = 0; i < phone_book.length - 1; i++){
            String s = phone_book[i];
            if(phone_book[i + 1].indexOf(s) == 0)
                return false;
        }
        return true;
    }
}
```