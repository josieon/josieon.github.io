---
layout: single
title: CM4
categories:
tag: [java]
---

## 문제
---

<img src = "https://user-images.githubusercontent.com/76546008/202070292-df080289-9277-4e22-a6f5-5fe405c1fc98.png"/>

<img src="https://user-images.githubusercontent.com/76546008/202070294-58d81bbc-cac1-4ecd-a10c-ba500b50fd59.png"/>

<img src="https://user-images.githubusercontent.com/76546008/202070295-5f7a1c01-14a0-4359-8c8e-db7962288aae.png"/>

<img src="https://user-images.githubusercontent.com/76546008/202070298-a73032dd-4a1f-4a1c-96b5-71f04e6aba1e.png"/>

<img src="https://user-images.githubusercontent.com/76546008/202070301-a6631dc9-6306-4ba1-807c-089a40f6d823.png"/>

<img src="https://user-images.githubusercontent.com/76546008/202070303-93d43264-2b70-4d12-80d2-19971fab8543.png"/>

<img src="https://user-images.githubusercontent.com/76546008/202070312-d11d59db-79a8-494f-8d8a-09f61ef1d393.png"/>

<img src="https://user-images.githubusercontent.com/76546008/202070318-5736d93b-62e1-43bb-967d-dba4f02dc247.png"/>

<img src="https://user-images.githubusercontent.com/76546008/202070325-6e9af3d9-8e95-4a55-b3c0-6b99c42e6eb0.png"/>

<img src="https://user-images.githubusercontent.com/76546008/202070329-02e8f7ea-d994-4e57-9908-9dc1721e1f60.png"/>

<img src="https://user-images.githubusercontent.com/76546008/202070335-24cdbc3d-50c2-4c12-bf5f-8af969b66bb0.png"/>

<img src="https://user-images.githubusercontent.com/76546008/202070343-8e876078-6444-4430-98b6-5f3f821605bb.png"/>


## 풀이
---
&nbsp;처음에는 규칙이 헷갈렸다. 루트 노드가 바뀔 때, 현재의 루트 노드와 바뀔 루트 노드를 바꾸는게 아닌, 정말 간선은 고정된 채로 노드의 위치만 바뀌는 것이다.

&nbsp;우선, 정답을 출력할 때, 입력할 때 들어온 간선에 매치되게 출력해야 하므로 해쉬를 사용했다. 부모 노드를 참조할 수 있는 배열을 만들어 진행하였다.

&nbsp;루트가 변경될 때마다, 대상 노드부터 루트 노드까지의 경로를 탐색해야 하므로, 대상 노드와 부모 변수를 이용해 스택에 삽입하며 루트 노드에 도달한다. 이 경로에 있는 모든 간선들은 관계가 역전될 간선이므로 해쉬를 이용해 정답 배열에 값을 갱신해준다.

&nbsp;루트 노드에 도달하였으므로, 스택에 있는 노드들을 비워주면서 역전된 간선들을 역추적하며 부모 변수를 갱신해준다.

```java
public static int[] solution(int[][] edges, int[] roots){
    HashMap<String, Integer> hash = new HashMap<>();

    // 간선들을 hash에 put
    for(int i = 0; i < edges.length; i++){
        int max = Math.max(edges[i][0], edges[i][1]);
        int min = Math.min(edges[i][0], edges[i][1]);
        hash.put(String.format("%d-%d", min, max), i);
    }
    int[] answer = new int[edges.length];   // 결과 변수
    int[] parent = new int[edges.length+2]; // 부모 변수

    // 부모 초기화
    for(int[] tmp : edges){
        parent[tmp[1]] = tmp[0];
    }

    // 루트 노드 변경 루프
    for(int root : roots){
        Stack<Integer> stk = new Stack<>();
        stk.add(root);
        int par = parent[root];
        
        // 대상 노드부터 루트 노드까지 탐색하여 스택에 삽입
        while(par != 0){
            stk.add(par);
            int min = Math.min(root, par);
            int max = Math.max(root, par);
            // 결과 갱신
            answer[hash.get(String.format("%d-%d", min, max))]++;
            root = par;
            par = parent[root];
        }

        // 스택에 있는 노드 간 관계 역전
        par = stk.pop();
        while(!stk.isEmpty()){
            root = stk.pop();
            parent[par] = root;
            parent[root] = 0;
            par = root;
        }
    }
    return answer;
}
```

&nbsp;컨디션이 좋아서 다시 풀어볼때는 쉽게 풀어보았으나 평소에도 풀기 어려웠을 문제라고 생각한다. 재범이와 1, 2, 4번을 풀어보았는데 해답이 없다보니 체념하고 문제에 더 집중하여 풀 수 있었던 것 같다. 컨디션이 좋았다면 시험 당시 더 잘 풀지 않았을까라는 생각이 들지만 컨디션 조절 역시 실력이기에 다음을 기약한다.