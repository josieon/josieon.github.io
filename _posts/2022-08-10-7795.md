---
layout: single
title: "7795번: 먹을 것인가 먹힐 것인가"
categories: BOJ
tag: [java, BOJ]
---

## 문제
---
심해에는 두 종류의 생명체 A와 B가 존재한다. A는 B를 먹는다. A는 자기보다 크기가 작은 먹이만 먹을 수 있다. 예를 들어, A의 크기가 {8, 1, 7, 3, 1}이고, B의 크기가 {3, 6, 1}인 경우에 A가 B를 먹을 수 있는 쌍의 개수는 7가지가 있다. 8-3, 8-6, 8-1, 7-3, 7-6, 7-1, 3-1.
<p align="center">
<img src="https://www.acmicpc.net/upload/images/ee(1).png">
</p>
두 생명체 A와 B의 크기가 주어졌을 때, A의 크기가 B보다 큰 쌍이 몇 개나 있는지 구하는 프로그램을 작성하시오.

## 입력
---
첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스의 첫째 줄에는 A의 수 N과 B의 수 M이 주어진다. 둘째 줄에는 A의 크기가 모두 주어지며, 셋째 줄에는 B의 크기가 모두 주어진다. 크기는 양의 정수이다. (1 ≤ N, M ≤ 20,000) 

## 출력
---
각 테스트 케이스마다, A가 B보다 큰 쌍의 개수를 출력한다.

### 예제 입력 1 

```
2
5 3
8 1 7 3 1
3 6 1
3 4
2 13 7
103 11 290 215
```

### 예제 출력 1 

```
7
1
```

## 풀이
---
1. 처음 접근
- 두 개의 ArrayList에 값들을 입력받는다. 배열이 아니라 ArrayList인 이유는 A는 내림차순으로 정렬하고, B는 오름차순으로 정렬하기 위해서이다. 배열이 아닌 ArrayList를 사용하여 Collections.sort를 사용하면 reverseOrder로 정렬이 가능하다.
- 그리고 A의 첫번째 원소부터 하나씩 꺼내고, B는 포인터를 B의 가장 뒤쪽 원소부터 가리키게 하여 줄여나가며 포인터 인덱스 값만큼 결과에 합산한다.
2. 두번째 접근
- 첫번째 방법으로 문제를 해결하여 정답 처리가 되었으나 708ms로 시간이 많이 소요된다는 생각이 들어 수정을 하고자 하였다.
- 변경사항은 ArrayList를 사용하여 get함수를 이용해 값을 참조하는 것이 아닌 배열을 사용하고 reverseOrder로 정렬할 필요없이 포인터를 하나 더 사용하였다.
- 변경 후, 448ms로 시간이 감소하였다.
3. 검색한 코드
- 다른 사람의 코드를 찾아보았는데, B만 정렬을 하고, A는 정렬을 하지 않고, A의 원소를 하나 꺼내어 매번 B를 탐색하여 카운트를 증가시키고, 카운트를 결과값에 합산해주는 식으로 하였다.
- Space Complexity는 큰 차이가 없다.
- Time Complexity는 내가 푼 방식의 경우 $NlogN$의 정렬이 필요하나, 검색한 코드의 경우에는 $N*M$만큼의 탐색이 더 필요하다.

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws Exception{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int T = Integer.parseInt(br.readLine());
        StringBuilder sb = new StringBuilder();
        for(int t = 0; t < T; t++){
            //입력 및 할당
            StringTokenizer st = new StringTokenizer(br.readLine());
            int N = Integer.parseInt(st.nextToken());
            int M = Integer.parseInt(st.nextToken());
            st = new StringTokenizer(br.readLine());
            int[] A = new int[N];
            for(int n = 0; n < N; n++)
                A[n] = Integer.parseInt(st.nextToken());
            st = new StringTokenizer(br.readLine());
            int[] B = new int[M];
            for(int m = 0; m < M; m++)
                B[m] = Integer.parseInt(st.nextToken());
            //정렬
            Arrays.sort(A);
            Arrays.sort(B);
            //포인터 할당
            int ptr = B.length - 1;
            int idx_cur = A.length - 1;
            int res = 0;    //결과
            //탐색 및 포인터 초기화
            while(ptr >= 0 && idx_cur >= 0){
                int cur = A[idx_cur--];
                while(ptr >= 0 && B[ptr] >= cur)
                    ptr--;
                res += ptr + 1;
            }
            sb.append(res).append("\n");
        }
        System.out.println(sb);
    }
}
```