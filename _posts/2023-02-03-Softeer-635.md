---
layout: single
title: "거리 합 구하기"
categories: Softeer
tag: [java, Softeer]
---

## 문제
---
현호는 사내 네트워크 분석 업무를 담당하게 되었다. 현재 사내 네트워크는 N개의 노드를 가지는 트리 형태의 네트워크인데, 이 말은 두 노드간의 연결이 정확히 N-1개 있어서 이 연결만으로 모든 노드간에 통신을 할 수 있다는 뜻이다.

각 노드에 1에서 N사이의 번호를 붙이면 i번째 연결은 xi번 노드와 yi번 노드를 양방향으로 연결하며, 통신에 걸리는 시간은 ti이다. D(i,j)는 i번 노드와 j번 노드 사이의 거리를 나타내는데, i번 노드에서 여러 연결을 거쳐 j번 노드에 도달하기 위해 걸리는 최소 시간이다.

노드를 들를 때 추가적인 작업이 없는 이상적인 시간을 따진다. 현호는 네트워크 분석을 위해 어떤 노드 i를 기준으로 다른 모든 노드 사이와의 거리의 합을 알고 싶다. 즉, 을 알고 싶다.

입력예제 2번을 예로 들면, 다음과 같이 7개의 노드로 이루어진 네트워크로 표현할 수 있다. 각 연결 위에 적힌 수는 t를 나타낸다.

<img src = "https://softeer.ai/upload/2021/10/20211027_105640571_67317.png">

1번 노드를 기준으로 $D(i, j)$를 구해보면 다음과 같다.

<img src = "https://softeer.ai/upload/2021/10/20211027_105658252_45336.png">


## 제한사항

---

- 1 ≤ N ≤ 2 × $10^5$

- 1 ≤ $t_i$ ≤ $10^6$

- 첫 번째 줄에 노드의 개수 N이 주어진다.

- 다음 N-1줄의 i번째 줄에는 i번째 연결을 나타내는 세 정수 $ x_i, y_i, t_i $가 주어진다.

- N개의 줄에 걸쳐서, i번째 줄에는 i번 노드와 다른 모든 노드사이의 거리의 합, $ \sum_{j=1}^ND(i,j) $를 출력한다.

### 입력예제1

```
4
1 2 1
2 3 2
3 4 4
```

### 출력예제1

```
11
9
9
17
```

### 입력예제2

```
7
1 2 5
1 3 2
1 4 8
3 5 4
3 6 1
4 7 6
```

### 출력예제2

```
38
63
40
62
50
45
92
```


## 풀이

---

구해야 하는 것은, 임의의 노드에서 출발하여 모든 노드를 방문하였을때의 비용의 합이다. 임의의 노드를 기점으로 하는 비용의 합을 모두 출력해야 하므로 결국 모든 노드를 기점으로 하는 반복문을 사용해야해서 플로이드 와샬 알고리즘을 생각했다. 그러나 데이터 사이즈가 200,000이기에 $ O(N^3) $으로는 어림도 없다는 생각이 들었다. 간선의 개수가 N-1인 트리라는 점에서 힌트를 얻어야 했는데, 도무지 아이디어가 떠오르지 않아 찾아보았다.

<img src = "https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbs3bEE%2FbtrobIb5sGu%2FKBkq9KUiegYjk5UZMPI66K%2Fimg.png">

1번 노드를 루트로 하고 노드간 거리의 합을 먼저 구해보자.

1번 노드가 루트 노드일때 트리의 노드의 개수는 7이다.(1, 2, 3, 4, 5, 6, 7)

1번 노드가 루트 노드일때, 3번 노드를 루트로 하는 서브트리의 노드의 개수는 3이다.(3, 5, 6)

3번 노드가 루트 노드일때 트리의 노드의 개수는 7이다.(1, 2, 3, 4, 5, 6, 7)

3번 노드가 루트 노드일때, 1번 노드를 루트로 하는 서브트리의 노드의 개수는 4이다.(1, 2, 4, 7)

1-3간선은 1번 노드가 루트일 때는 3회 지난다. 1-3간선은 3번 노드가 루트일 때는 4회 지난다. 나머지 간선들은 1번 노드와 3번 노드가 전체 트리의 루트일때, 같은 횟수로 지난다.

따라서, 어떤 간선은 그 간선으로 이어진 노드간 서로 루트일 때 지나는 횟수의 합은 N이다.

또, A가 전체 트리의 루트이고 그 자식인 B가 루트인 서브트리의 노드의 수가 x이면 A와 B사이의 간선을 x번 지나며 B가 전체 트리의 루트일 때를 고려하지 않아도 그 간선을 N-x번 지나간다는 것을 알 수 있다. 또, 나머지 간선을 몇번 지나는지 구하지 않더라도 전체 노드간 거리의 합을 구할 수 있다는 것이다.

위의 말은 즉, 1번 노드를 루트 노드로 하여 전체 비용 합을 구하고 나면, 1번 노드와 연결된 2, 3, 4번 노드가 루트 노드일 때의 비용을 구할 수 있다는 것이다.

1번 노드가 전체 트리의 루트이면,

2번 노드가 루트인 서브트리의 노드의 수는 1이므로 1-2 간선은 1번 지나며, B가 전체 트리의 루트일 때는 1-2 간선을 6번 지난다. 또한, 비용은 ( 1번 노드가 루트인 비용 ) + ( 1-2 간선의 비용 ) × ( N - 2 × ( 1번 노드가 루트일때 1-2 간선을 지나는 횟수 ) )인 것이다. 따라서, 1번 노드가 루트인 트리에서 비용이 38이므로, ( 38 + 5 × ( 7 - 2 × 1 ) )이 되어, 63이 된다.

```java
public static int N;
public static long[] ans;
public static int[] parent;
public static int[] childCnt;
// 간선을 나타내는 클래스
public static class Node{
    int num;    // destination
    long cost;  // cost
    public Node(){}
    public Node(int a, long b){
        num = a;
        cost = b;
    }
}
// 결과값 클래스
public static class Info{
    int branchCnt;  // 간선을 지나야 하는 횟수
    long costSum;   // 노드를 루트 노드로 하는 서브트리의 비용 합
}
public static ArrayList<Node>[] adj;   // 간선을 담는 리스트
public static Info dfs(int curNode, int par){
    Info ret = new Info();
    parent[curNode] = par;
    // 간선들을 순환하며 결과값 갱신
    for(int i = 0; i < adj[curNode].size(); i++){
        int nextNode = adj[curNode].get(i).num;
        long cost = adj[curNode].get(i).cost;
        // curNode가 전체 트리의 루트가 아닌 서브 트리의 루트인 경우
        // 부모 노드에 대한 간선은 skip
        if(nextNode == par)
            continue;
        // 간선으로 연결된 자식 노드를 루트노드로 하는 서브 트리에 대해 dfs호출.
        Info child = dfs(nextNode, curNode);    // 자식 노드의 결과값
        ret.costSum += cost * child.branchCnt + child.costSum;  // 현재 간선의 비용 * 현재 간선을 지나야 하는 횟수 + 자식 노드를 루트 노드로 하는 서브트리의 비용 합
        ret.branchCnt += child.branchCnt;   // 간선을 지나야 하는 횟수 갱신
    }
    ret.branchCnt += 1; // 자신을 포함시킴
    childCnt[curNode] = ret.branchCnt;
    return ret;
}
public static void main(String[] args) throws Exception{
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    N = Integer.parseInt(br.readLine());
    adj = new ArrayList[N+1];
    ans = new long[N+1];
    parent = new int[N+1];
    childCnt = new int[N+1];
    for(int i = 1; i <= N; i++)
        adj[i] = new ArrayList<Node>();
    for(int i = 0; i < N-1; i++){
        StringTokenizer st = new StringTokenizer(br.readLine());
        int s = Integer.parseInt(st.nextToken());
        int e = Integer.parseInt(st.nextToken());
        long c = Integer.parseInt(st.nextToken());
        adj[s].add(new Node(e, c));
        adj[e].add(new Node(s, c));
    }
    Info root = dfs(1, 0);  // 1번 노드를 루트로 하는 트리의 결과값
    ans[1] = root.costSum;
    // 루트 노드에 연결된 간선을 큐에 삽입
    Queue<Node> q = new LinkedList<Node>();
    for(int i = 0; i < adj[1].size(); i++){
        q.add(new Node(adj[1].get(i).num, 0));
    }

    while(!q.isEmpty()){
        Node curNode = q.poll();    // 간선에 연결된 자식 노드
        // 자식 노드에 연결된 간선 반복문
        for(int i = 0; i < adj[curNode.num].size(); i++){
            int nextNode = adj[curNode.num].get(i).num;
            long cost = adj[curNode.num].get(i).cost;
            // 값이 갱신이 되어있는 경우, 정답 갱신
            if(parent[curNode.num] == nextNode)
                ans[curNode.num] += ans[nextNode] + ( N - 2 * childCnt[curNode.num]) * cost;
            if(parent[curNode.num] == nextNode)
                continue;
            q.add(new Node(nextNode, 0));
        }
    }
}
```